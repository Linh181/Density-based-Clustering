def plot_boxgraph(bg):
    '''Plots the points contained in the box-graph, and the boxes generated by the algorithm'''
    import matplotlib.pyplot as plt
    import pandas as pd
    
    # get dataframe of point coordinates
    df = pd.DataFrame([[float(j) for j in p.__str__().split()[:3]] for p in bg.points])
    
    # get list of rectangle coordinates, widths and heights
    rec = [{'coords': (box.bounds['left'], box.bounds['bottom']),
           'width'  : box.bounds['right'] - box.bounds['left'],
           'height' : box.bounds['top']   - box.bounds['bottom']}
           for box in bg.boxes]
    
    
    ax = df.plot(kind='scatter', x=0, y=1, c=2, colormap='tab20', colorbar=False)
    
    for r in rec:
        shape = plt.Rectangle(r['coords'], r['width'], r['height'])
        ax.add_patch(shape)

def plot_quadtree(QT, ds):
    '''
    Plots the given QuadTree object on top of the dataset
    QT: quadtree object
    ds: dataset object
    '''
    import matplotlib.pyplot as plt
    import pandas as pd
    
    # get list of rectangle coordinates, widths and heights
    rec = [get_square_data(QT.root_node.square)]
    stack = [QT.root_node]
    while stack:
        u = stack.pop()
        for v in u.children:
            rec.append(get_square_data(v.square))
            stack.append(v)
    
    # get dataframe of point coordinates
    df = pd.DataFrame([[float(j) for j in p.__str__().split()[:3]] for p in ds.cluster_points])
    
    # create plots
    ax = df.plot(kind='scatter', x=0, y=1, c=2, colormap='tab20', colorbar=False)
    
    for r in rec:
        shape = plt.Rectangle(r['coords'], r['width'], r['height'], fill=False)
        ax.add_patch(shape)

def print_quadtree(node, prefix=''):
    '''
    returns: iterable
    Print the quadtree in unix -tree- command style, starting from given node.
    Uses recursion.
    
    Adapted from: https://stackoverflow.com/a/59109706
    
    Example usage:
    
    for line in print_quadtree(root_node):
        print(line)
    '''
    
    # pointer components
    tee = '├──'
    last = '└──'
    # prefix components
    indent = '    '
    branch = '│   '
    
    if node.parent is None:
        yield 'Node'
    
    pointers = [tee] * 3 + [last]
    
    if node.children:
        for pointer, child in zip(pointers, node.children):
            yield prefix + pointer + 'Node'
            
            extension = branch if pointer == tee else indent
            yield from print_quadtree(child, prefix+extension)
            
    elif node.point is not None:
        yield prefix + node.point.__str__()